#define MY_VERSION "1.6"

/*
	change log

2005-02-04 16:08 UTC - kode54
- Added threaded database synchronization system, with progress display and cancellation support
- All tracking is restricted to "permanent" cached items only
- Version is now 1.6

2005-01-25 21:04 UTC - kode54
- Added database library info and selection when multiple libraries are installed

2005-01-24 08:10 UTC - kode54
- Simple support for using either libmysql or SQLite

*/

#include <ptypes.h>
#include <ptime.h>
#include <pinet.h>  // this includes winsock.h on windows for mysql.h to compile
#include <pasync.h>

#include <mysql.h>
#include <sqlite3.h>

USING_PTYPES

#include "../SDK/foobar2000.h"
#include "../helpers/wildcard.h"
#include "resource.h"

/* Query to create the table, as generated by phpMyAdmin v2.5.6 (Why yes, I am lazy)

CREATE TABLE `playcount` (
`url` text character set utf8 NOT NULL,
`subsong` int(11) NOT NULL default '0',
`count` bigint(20) unsigned NOT NULL default '0',
`timestamp` bigint(20) unsigned NOT NULL default '0',
PRIMARY KEY  (`url`(256),`subsong`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

*/

static const char * query_create_mysql[] =

{"CREATE TABLE `", "` ("
"`url` text character set utf8 NOT NULL,"
"`subsong` int(11) NOT NULL default '0',"
"`count` bigint(20) unsigned NOT NULL default '0',"
"`timestamp` bigint(20) unsigned NOT NULL default '0',"
"PRIMARY KEY  (`url`(256),`subsong`)"
") ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci"};

static const char query_create[] =

"CREATE TABLE playcount ("
"url text NOT NULL,"
"subsong integer(8) NOT NULL default '0',"
"count integer(8) NOT NULL default '0',"
"timestamp integer(8) NOT NULL default '0',"
"PRIMARY KEY (url, subsong)"
")";

static const char * query_select_mysql[] = {"SELECT `count`, `timestamp` FROM `",
											"` WHERE (`url` = '",
											"') AND (`subsong` = ",
											") LIMIT 1"};
static const char   query_select[] =        "SELECT count, timestamp FROM playcount WHERE (url = ?) AND (subsong = ?) LIMIT 1";

static const char * query_update_mysql[] = {"UPDATE `",
											"` SET `count` = ",
											", `timestamp` = ",
											" WHERE (`url` = '",
											"') AND (`subsong` = ",
											") LIMIT 1"};
static const char   query_update[]       =  "UPDATE playcount SET count = ?, timestamp = ? WHERE (url = ?) AND (subsong = ?)";

static const char * query_insert_mysql[] = {"INSERT INTO `",
											"` VALUES ('",
											"', ",
											", ",
											", ",
											")"};
static const char   query_insert[]       =  "INSERT INTO playcount VALUES (?, ?, ?, ?)";

static const char * query_delete_mysql[] = {"DELETE FROM `",
											"` WHERE (`url` = '",
											"') AND (`subsong` = ",
											") LIMIT 1"};
static const char   query_delete[]       =  "DELETE FROM playcount WHERE (url = ?) AND (subsong = ?)";

static const char * query_update_path_mysql[] = {"UPDATE `",
												 "` SET `url` = '",
												 "', `subsong` = ",
												 " WHERE (`url` = '",
												 "') AND (`subsong` = '",
												 "') LIMIT 1"};
static const char   query_update_path[]       =  "UPDATE playcount SET url = ?, subsong = ? WHERE (url = ?) AND (subsong = ?)";

static const char * query_count_mysql[] = {"SELECT COUNT(*) FROM `",
										   "`"};
static const char   query_count[]       =  "SELECT COUNT(*) FROM playcount";

static const char * query_sync_mysql[] = {"SELECT `url`, `subsong`, `count`, `timestamp` FROM `",
										  "`"};
static const char   query_sync[]       = "SELECT url, subsong, count, timestamp FROM playcount";

// {1EE66DAF-3855-419d-A390-A419C5E6458E}
static const GUID guid_cfg_update_perc = 
{ 0x1ee66daf, 0x3855, 0x419d, { 0xa3, 0x90, 0xa4, 0x19, 0xc5, 0xe6, 0x45, 0x8e } };
// {E47C2396-587F-4774-9407-78569379916B}
static const GUID guid_cfg_stamp1_tag = 
{ 0xe47c2396, 0x587f, 0x4774, { 0x94, 0x7, 0x78, 0x56, 0x93, 0x79, 0x91, 0x6b } };
// {B86F2EDD-70A7-4e82-9F5F-90F7F577912C}
static const GUID guid_cfg_stamp2_tag = 
{ 0xb86f2edd, 0x70a7, 0x4e82, { 0x9f, 0x5f, 0x90, 0xf7, 0xf5, 0x77, 0x91, 0x2c } };
// {45412741-C3D5-494e-AFA5-EB7BAF46EBA4}
static const GUID guid_cfg_stamp1_format = 
{ 0x45412741, 0xc3d5, 0x494e, { 0xaf, 0xa5, 0xeb, 0x7b, 0xaf, 0x46, 0xeb, 0xa4 } };
// {0C4C171E-8E2D-4922-AD3F-89373EB223EC}
static const GUID guid_cfg_stamp2_format = 
{ 0xc4c171e, 0x8e2d, 0x4922, { 0xad, 0x3f, 0x89, 0x37, 0x3e, 0xb2, 0x23, 0xec } };
// {F5A461FD-0BAA-45d8-8651-4FB6415A90D9}
static const GUID guid_cfg_sql_host = 
{ 0xf5a461fd, 0xbaa, 0x45d8, { 0x86, 0x51, 0x4f, 0xb6, 0x41, 0x5a, 0x90, 0xd9 } };
// {95211A32-19D3-418d-8AB9-1E0B29DA2F20}
static const GUID guid_cfg_sql_user = 
{ 0x95211a32, 0x19d3, 0x418d, { 0x8a, 0xb9, 0x1e, 0xb, 0x29, 0xda, 0x2f, 0x20 } };
// {99DB7110-ED90-4e4b-BB01-A6BD8054B976}
static const GUID guid_cfg_sql_password = 
{ 0x99db7110, 0xed90, 0x4e4b, { 0xbb, 0x1, 0xa6, 0xbd, 0x80, 0x54, 0xb9, 0x76 } };
// {499F3B3B-E9F4-4784-AD4D-946D6508CD57}
static const GUID guid_cfg_sql_db = 
{ 0x499f3b3b, 0xe9f4, 0x4784, { 0xad, 0x4d, 0x94, 0x6d, 0x65, 0x8, 0xcd, 0x57 } };
// {F6418284-D296-428b-B179-041B9D216ABC}
static const GUID guid_cfg_sql_table = 
{ 0xf6418284, 0xd296, 0x428b, { 0xb1, 0x79, 0x4, 0x1b, 0x9d, 0x21, 0x6a, 0xbc } };


static cfg_int 
	cfg_update_perc(guid_cfg_update_perc,50);

static cfg_string 
	cfg_stamp1_tag(guid_cfg_stamp1_tag,"play_date"),
	cfg_stamp2_tag(guid_cfg_stamp2_tag,"play_time"),
	cfg_stamp1_format(guid_cfg_stamp1_format,"%d%m%y"),
	cfg_stamp2_format(guid_cfg_stamp2_format,"%H%M%S"),

	cfg_sql_host(guid_cfg_sql_host, "localhost"),
	cfg_sql_user(guid_cfg_sql_user, "foo"),
	cfg_sql_password(guid_cfg_sql_password, "bar"),
	cfg_sql_db(guid_cfg_sql_db, "foobar"),
	cfg_sql_table(guid_cfg_sql_table, "playcount");

static const char
	field_counter[] = "play_counter",
	field_timestamp[] = "play_timestamp";

// custom cfg_var class to store the played info.
// see below for an explanation on why this is even
// used...
class cfg_playcount_bittable : public cfg_var
{
private:
	bit_array_bittable val;
	unsigned           len;

public:
	explicit inline cfg_playcount_bittable(const GUID & p_guid):cfg_var(p_guid),val(0),len(0){}

	virtual bool get_raw_data(write_config_callback * out)
	{
		if ( len == 0 )
			return false;

		out->write_dword_le(len);

		char c=0;
		int bit=0;
		for(unsigned i=0;i<len;i++)
		{
			bool b = val.get(i);
			c |= b << bit++;
			if (bit==8)
			{
				out->write_byte(c);
				bit = c = 0;
			}
		}
		if (c)
			out->write_byte(c);

		return true;
	}

	virtual void set_raw_data(const void * data,int size)
	{
		read_config_helper r(data,size);
		
		t_uint32 d;
		r.read_dword_le(d);
		len = (unsigned)d;

		val.resize(len);
		unsigned sec = 0;
		unsigned blen = (len + 7)/8;
		for(unsigned i=0;i<blen;i++)
		{
			BYTE b;
			r.read_byte(b);

			for(unsigned bit=0;bit<8;bit++)
			{
				bool set = (b>>bit)&0x1;
				if (set)
					val.set(sec,true);
				sec++;
			}
		}
	}

	void set_table(bit_array_bittable &table,unsigned count)
	{
		len = count;
		val.resize(count);
		for(unsigned i = 0;i<count;i++)
			val.set(i,table.get(i));
	}

	void get_table(bit_array_bittable &out_table,unsigned &out_len)
	{
		out_table.resize(len);
		out_len = len;

		if (len)
		{
			for(unsigned i=0;i<len;i++)
				out_table.set(i,val.get(i));
		}
	}

	void clear()
	{
		val.resize(0);
		len = 0;
	}

	unsigned get_count(){ return len; }
};

//
// Explanation of these...
//
// These are here only to determine when a track is being played
// due to a restart of fb2k and "Resume playback after restart"
// is enabled (in Core).  There is no real way to determine when
// this happens, and so must be inferred.
//
// Some basic explanations:
// 1) When shutting down, "on_playback_stop" is called with a reason of
// play_control::STOP_REASON_USER, followed later by a call to 
// initquit::on_quit.
// 2) Of course, if the user manually invokes stop (ex. presses the
// Stop button), we get a call to "on_playback_stop" with a reason
// of play_control::STOP_REASON_USER.  If the user then shuts down
// fb2k, we then get a call to initquit::on_quit.
// 3) In other words... there is no way to tell the difference when
// shutting down whether a track is even playing, or the track is 
// is being stopped due to shutdown.  Therefore... there is no way
// to store info just in the case of shutting down during track
// playback.
// 4) When fb2k is restarting playback, there is no definitive way
// to know it's being restarted vs. started.
//
// Worked around it by:
// 1)When shutdown happens, the info for the previously playing file
// is stored.
// 2)The next time playback is started, when the "on_playback_time" 
// is called, if the track is being restarted by fb2k, the "val" 
// argument starts at the last played position (instead of 1.0).  
// In this case, the last play info is used.
// 3) If a file wasn't being played when fb2k was shutdown, then 
// the next play start starts at 1.0, and the last play info is
// discarded.
//
// It's all kind of hokie... bordering on hack.  But fb2k simply
// doesn't provide a way (that I can see) to determine when a 
// a track is being played due to a restart; or if a track is being
// stopped because fb2k is being shutdown.
//
// If fb2k ever changes the behavior of on_playback_time in the case
// of a restart, then this technique will NOT work.
//

// {466FFE32-9401-4f2f-B4A9-D97BADE2150A}
static const GUID guid_cfg_last_played = 
{ 0x466ffe32, 0x9401, 0x4f2f, { 0xb4, 0xa9, 0xd9, 0x7b, 0xad, 0xe2, 0x15, 0xa } };
// {0F4F2D26-5D79-44d7-ADA5-8963F6CCE45D}
static const GUID guid_cfg_last_path = 
{ 0xf4f2d26, 0x5d79, 0x44d7, { 0xad, 0xa5, 0x89, 0x63, 0xf6, 0xcc, 0xe4, 0x5d } };
// {132DECB6-0204-4147-8174-E43BB93C241B}
static const GUID guid_cfg_last_subsong = 
{ 0x132decb6, 0x204, 0x4147, { 0x81, 0x74, 0xe4, 0x3b, 0xb9, 0x3c, 0x24, 0x1b } };

static cfg_playcount_bittable cfg_last_played(guid_cfg_last_played);
static cfg_string cfg_last_path(guid_cfg_last_path,"");
static cfg_int cfg_last_subsong(guid_cfg_last_subsong, 0);

static bit_array_bittable g_played(0);
static unsigned g_length = 0;

string format( datetime dt, const char *format )
{
	tzupdate();
	return dttostring(dt + tzoffset() * 60000, format);
}

class my_startup;

class state_mysql
{
	friend class my_startup;

protected:
	bool present;

private:
	critical_section sync;
	MYSQL * mysql;

	string8_fastalloc errmsg;

public:
	state_mysql()
	{
		present = false;
		mysql = 0;
		errmsg = "libmysql.dll not found";
	}

	~state_mysql()
	{
		insync(sync);
		if (mysql) mysql_close(mysql);
	}

	bool is_present() const
	{
		return present;
	}

	const char * get_last_error() const
	{
		return errmsg;
	}

private:
	void format_error()
	{
		uPrintf(errmsg, "Error %u: %s", mysql_errno(mysql), mysql_error(mysql));
	}

public:
	bool init()
	{
		insync(sync);
		if (mysql) return true;

		mysql = mysql_init(NULL);

		if (mysql == 0)
		{
			errmsg = "Unable to allocate new MYSQL structure";
			return false;
		}

		MYSQL * res = mysql_real_connect(mysql, cfg_sql_host, cfg_sql_user, cfg_sql_password, cfg_sql_db, 0, NULL, 0);
		if (!res)
		{
			format_error();
			mysql_close(mysql);
			mysql = 0;
			return false;
		}
		return true;
	}

	bool create_table()
	{
		insync(sync);
		if (!init()) return false;

		string_simple query;
		query = query_create_mysql[0];
		query += cfg_sql_table;
		query += query_create_mysql[1];
		if (mysql_real_query(mysql, pconst(query), query.length()))
		{
			format_error();
			return false;
		}

		return true;
	}

private:
	bool ping()
	{
		if (!init()) return false;

		if (mysql_ping(mysql))
		{
			mysql_close(mysql);
			mysql = 0;

			if (!init()) return false;
		}

		return true;
	}

public:
	large * query(const char * url, int subsong, large timestamp = 0) // non-zero timestamp to update count
	{
		insync(sync);

		if (!ping()) return false;

		string_simple table(cfg_sql_table);

		size_t len = strlen(url);
		mem_block_t<char> e_url(len * 2 + 1);
		mysql_real_escape_string(mysql, e_url.get_ptr(), url, len);

		string8_fastalloc query;
		query = query_select_mysql[0];
		query += table;
		query += query_select_mysql[1];
		query += e_url;
		query += query_select_mysql[2];
		query.add_int(subsong);
		query += query_select_mysql[3];
		if (mysql_real_query(mysql, pconst(query), query.length()))
		{
			format_error();
			return 0;
		}

		large * ret = new large[2];

		MYSQL_RES * res = mysql_use_result(mysql);
		if (!res)
		{
			if (mysql_errno(mysql) != 0)
			{
				format_error();
				delete [] ret;
				return 0;
			}
			ret[0] = 0;
		}
		else
		{
			MYSQL_ROW row = mysql_fetch_row(res);
			if (!row)
			{
				if (mysql_errno(mysql) != 0)
				{
					format_error();
					mysql_free_result(res);
					delete [] ret;
					return 0;
				}
				ret[0] = 0;
			}
			else
			{
				int num_fields = int(mysql_num_fields(res));
				if (!row[0]) ret[0] = 0;
				else ret[0] = stringtoi(row[0]);
				if (!row[1]) ret[1] = 0;
				else ret[1] = stringtoi(row[1]);
			}
			mysql_free_result(res);
		}

		if (timestamp)
		{
			if (!ret[0])
			{
				ret[0] = 1;
				ret[1] = timestamp;
				query = query_insert_mysql[0];
				query += table;
				query += query_insert_mysql[1];
				query += e_url;
				query += query_insert_mysql[2];
				query.add_int(subsong);
				query += query_insert_mysql[3];
				query.add_int(ret[0]);
				query += query_insert_mysql[4];
				query.add_int(ret[1]);
				query += query_insert_mysql[5];
			}
			else
			{
				ret[0] ++;
				if (ret[1] < timestamp) ret[1] = timestamp;
				query = query_update_mysql[0];
				query += table;
				query += query_update_mysql[1];
				query.add_int(ret[0]);
				query += query_update_mysql[2];
				query.add_int(ret[1]);
				query += query_update_mysql[3];
				query += e_url;
				query += query_update_mysql[4];
				query.add_int(subsong);
				query += query_update_mysql[5];
			}

			if (mysql_real_query(mysql, pconst(query), query.length()))
			{
				format_error();
				delete [] ret;
				return 0;
			}
		}

		return ret;
	}

	bool remove(const char * url, int subsong)
	{
		insync(sync);
		if (!ping()) return false;

		size_t len = strlen(url);
		mem_block_t<char> e_url(len * 2 + 1);
		mysql_real_escape_string(mysql, e_url.get_ptr(), url, len);

		string8_fastalloc query;
		query = query_delete_mysql[0];
		query += cfg_sql_table;
		query += query_delete_mysql[1];
		query += e_url;
		query += query_delete_mysql[2];
		query.add_int(subsong);
		query += query_delete_mysql[3];
		if (mysql_real_query(mysql, pconst(query), query.length()))
		{
			format_error();
			return false;
		}

		return true;
	}

	bool moved(const char * url, int subsong, const char * new_url, int new_subsong)
	{
		insync(sync);
		if (!ping()) return false;

		size_t len = strlen(url);
		mem_block_t<char> e_url(len * 2 + 1);
		mysql_real_escape_string(mysql, e_url.get_ptr(), url, len);

		len = strlen(new_url);
		mem_block_t<char> e_new_url(len * 2 + 1);
		mysql_real_escape_string(mysql, e_new_url.get_ptr(), new_url, len);

		string8_fastalloc query;
		query = query_update_path_mysql[0];
		query += cfg_sql_table;
		query += query_update_path_mysql[1];
		query += e_new_url;
		query += query_update_path_mysql[2];
		query.add_int(new_subsong);
		query += query_update_path_mysql[3];
		query += e_url;
		query += query_update_path_mysql[4];
		query.add_int(subsong);
		query += query_update_path_mysql[5];
		if (mysql_real_query(mysql, pconst(query), query.length()))
		{
			format_error();
			return false;
		}

		return true;
	}

	bool resync(threaded_process_status & s)
	{
		insync(sync);
		if (!ping()) return false;

		unsigned count, total;

		service_ptr_t<metadb> p_metadb;
		service_ptr_t<library_manager> p_library;
		metadb::g_get(p_metadb);
		library_manager::g_get(p_library);

		string_simple table(cfg_sql_table);
		string_simple query;
		query = query_count_mysql[0];
		query += table;
		query += query_count_mysql[1];
		if (mysql_real_query(mysql, pconst(query), query.length()))
		{
			format_error();
			return false;
		}

		MYSQL_RES * res = mysql_use_result(mysql);
		if (!res)
		{
			format_error();
			return false;
		}
		else
		{
			MYSQL_ROW row = mysql_fetch_row(res);

			if (!row)
			{
				format_error();
				mysql_free_result(res);
				return false;
			}
			count = 0;
			total = atoi(row[0]);
			mysql_free_result(res);
		}

		query = query_sync_mysql[0];
		query += cfg_sql_table;
		query += query_sync_mysql[1];

		if (mysql_real_query(mysql, pconst(query), query.length()))
		{
			format_error();
			return false;
		}

		res = mysql_use_result(mysql);
		if (!res)
		{
			if (mysql_errno(mysql) != 0)
			{
				format_error();
				return false;
			}
		}
		else
		{
			MYSQL_ROW row;
			metadb_handle_ptr handle;
			metadb_handle_list dead;
			file_info_impl info;

			string stamp1_tag(cfg_stamp1_tag), stamp1_format(cfg_stamp1_format),
				stamp2_tag(cfg_stamp2_tag), stamp2_format(cfg_stamp2_format);

			abort_callback_impl m_abort;
			static_api_ptr_t<metadb_io> p_imgr;

			while (s.process_pause() && (row = mysql_fetch_row(res)))
			{
				if (row[0] && row[1])
				{
					s.set_item_path(row[0]);
					p_metadb->handle_create(handle, make_playable_location(row[0], atoi(row[1])));
					if (input_entry::g_is_item_dead(handle->get_location(), m_abort) ||
						!p_library->is_item_in_library(handle)) dead.add_item(handle);
					else if (row[2] && row[3])
					{
						large q[2] = {stringtoi(row[2]), stringtoi(row[3])};
						handle->metadb_lock();
						if (handle->get_info(info))
						{
							info.info_set_int(field_counter, q[0]);
							info.info_set_int(field_timestamp, q[1]);
							if (length(stamp1_tag))
							{
								string val = format( q[1], stamp1_format );
								if (length(val))
									info.info_set(stamp1_tag,val);
							}
							if (length(stamp2_tag))
							{
								string val = format( q[1], stamp2_format );
								if (length(val))
									info.info_set(stamp2_tag,val);
							}
							p_imgr->update_info(handle, info, core_api::get_main_window(), true);
						}
						handle->metadb_unlock();
					}
				}

				s.set_progress(++count, total);
			}

			if (mysql_errno(mysql) != 0)
			{
				format_error();
				mysql_free_result(res);
				return false;
			}
			mysql_free_result(res);

			if (dead.get_count())
			{
				s.set_title("Removing dead tracks...");
				s.set_progress(threaded_process_status::progress_min);
				for (unsigned i = 0, j = dead.get_count(); s.process_pause() && (i < j);)
				{
					const playable_location & loc = dead.get_item(i)->get_location();
					s.set_item_path(loc.get_path());
					if (!remove(loc.get_path(), loc.get_subsong())) return false;
					s.set_progress(++i, j);
				}
			}
		}

		return true;
	}
};

class state_sqlite
{
	friend class my_startup;

protected:
	bool present;

private:
	critical_section sync;
	sqlite3 * sqlite;

	string8_fastalloc errmsg;

	sqlite3_stmt * stmt[7];

	enum
	{
		stmt_select = 0,
		stmt_update,
		stmt_insert,
		stmt_delete,
		stmt_update_path,
		stmt_count,
		stmt_sync
	};
	

public:
	state_sqlite()
	{
		present = false;
		sqlite = 0;
		memset(&stmt, 0, sizeof(stmt));
		errmsg = "sqlite.dll not found";
	}

	~state_sqlite()
	{
		insync(sync);
		for (unsigned i = 0; i < 6; i++)
		{
			if (stmt[i]) sqlite3_finalize(stmt[i]);
		}
		if (sqlite) sqlite3_close(sqlite);
	}

	bool is_present() const
	{
		return present;
	}

	const char * get_last_error() const
	{
		return errmsg;
	}

	bool init()
	{
		insync(sync);
		if (sqlite) return true;

		string8_fastalloc db;
		db  = core_api::get_profile_path();
		db += "playcount.db";

		bool need_create = false;
		uFindFile * f = uFindFirstFile(db);

		if (!f) need_create = true;
		else delete f;

		if (sqlite3_open(db, &sqlite))
		{
			errmsg = sqlite3_errmsg(sqlite);
			sqlite3_close(sqlite);
			sqlite = 0;
			return false;
		}

		if (need_create)
		{
			char * error;
			if (sqlite3_exec(sqlite, query_create, NULL, NULL, &error))
			{
				errmsg = error;
				sqlite3_free(error);
				return false;
			}
		}

		if (sqlite3_prepare(sqlite, query_select, strlen(query_select), &stmt[stmt_select], NULL) ||
			sqlite3_prepare(sqlite, query_update, strlen(query_update), &stmt[stmt_update], NULL) ||
			sqlite3_prepare(sqlite, query_insert, strlen(query_insert), &stmt[stmt_insert], NULL) ||
			sqlite3_prepare(sqlite, query_delete, strlen(query_delete), &stmt[stmt_delete], NULL) ||
			sqlite3_prepare(sqlite, query_update_path, strlen(query_update_path), &stmt[stmt_update_path], NULL) ||
			sqlite3_prepare(sqlite, query_count, strlen(query_count), &stmt[stmt_count], NULL) ||
			sqlite3_prepare(sqlite, query_sync, strlen(query_sync), &stmt[stmt_sync], NULL))
		{
			errmsg = sqlite3_errmsg(sqlite);
			sqlite3_close(sqlite);
			sqlite = 0;
			return false;
		}

		return true;
	}

	large * query(const char * url, int subsong, large timestamp = 0) // non-zero timestamp to update count
	{
		insync(sync);

		if (!init()) return 0;

		large * ret = new large[2];

		ret[0] = 0;

		if (sqlite3_reset(stmt[stmt_select]) ||
			sqlite3_bind_text(stmt[stmt_select], 1, url, strlen(url), SQLITE_STATIC) ||
			sqlite3_bind_int(stmt[stmt_select], 2, subsong))
		{
			errmsg = sqlite3_errmsg(sqlite);
			delete [] ret;
			return 0;
		}

		int rc = sqlite3_step(stmt[stmt_select]);

		if (rc != SQLITE_DONE && rc != SQLITE_ROW)
		{
			errmsg = sqlite3_errmsg(sqlite);
			delete [] ret;
			return 0;
		}

		if (rc == SQLITE_ROW)
		{
			ret[0] = sqlite3_column_int64(stmt[stmt_select], 0);
			ret[1] = sqlite3_column_int64(stmt[stmt_select], 1);
		}

		sqlite3_reset(stmt[stmt_select]);

		if (timestamp)
		{
			sqlite3_stmt * st;
			if (!ret[0])
			{
				ret[0] = 1;
				ret[1] = timestamp;
				st = stmt[stmt_insert];
				if (sqlite3_reset(st) ||
					sqlite3_bind_text(st, 1, url, strlen(url), SQLITE_STATIC) ||
					sqlite3_bind_int(st, 2, subsong) ||
					sqlite3_bind_int64(st, 3, ret[0]) ||
					sqlite3_bind_int64(st, 4, ret[1]) ||
					sqlite3_step(st) != SQLITE_DONE ||
					sqlite3_reset(st))
				{
					errmsg = sqlite3_errmsg(sqlite);
					delete [] ret;
					return 0;
				}
			}
			else
			{
				ret[0] ++;
				if (ret[1] < timestamp) ret[1] = timestamp;
				st = stmt[stmt_update];
				if (sqlite3_reset(st) ||
					sqlite3_bind_int64(st, 1, ret[0]) ||
					sqlite3_bind_int64(st, 2, ret[1]) ||
					sqlite3_bind_text(st, 3, url, strlen(url), SQLITE_STATIC) ||
					sqlite3_bind_int(st, 4, subsong) ||
					sqlite3_step(st) != SQLITE_DONE ||
					sqlite3_reset(st))
				{
					errmsg = sqlite3_errmsg(sqlite);
					delete [] ret;
					return 0;
				}
			}
		}

		return ret;
	}

	bool remove(const char * url, int subsong)
	{
		insync(sync);
		if (!init()) return false;

		if (sqlite3_reset(stmt[stmt_delete]) ||
			sqlite3_bind_text(stmt[stmt_delete], 1, url, strlen(url), SQLITE_STATIC) ||
			sqlite3_bind_int(stmt[stmt_delete], 2, subsong) ||
			sqlite3_step(stmt[stmt_delete]) != SQLITE_DONE ||
			sqlite3_reset(stmt[stmt_delete]))
		{
			errmsg = sqlite3_errmsg(sqlite);
			return false;
		}

		return true;
	}

	bool moved(const char * url, int subsong, const char * new_url, int new_subsong)
	{
		insync(sync);
		if (!init()) return false;

		if (sqlite3_reset(stmt[stmt_update_path]) ||
			sqlite3_bind_text(stmt[stmt_update_path], 1, new_url, strlen(new_url), SQLITE_STATIC) ||
			sqlite3_bind_int(stmt[stmt_update_path], 2, new_subsong) ||
			sqlite3_bind_text(stmt[stmt_update_path], 3, url, strlen(url), SQLITE_STATIC) ||
			sqlite3_bind_int(stmt[stmt_update_path], 4, subsong) ||
			sqlite3_step(stmt[stmt_update_path]) != SQLITE_DONE ||
			sqlite3_reset(stmt[stmt_update_path]))
		{
			errmsg = sqlite3_errmsg(sqlite);
			return false;
		}

		return true;
	}

	bool resync(threaded_process_status & s)
	{
		insync(sync);
		if (!init()) return false;

		unsigned count, total;

		service_ptr_t<metadb> p_metadb;
		service_ptr_t<library_manager> p_library;
		metadb::g_get(p_metadb);
		library_manager::g_get(p_library);

		if (sqlite3_reset(stmt[stmt_count]) ||
			sqlite3_reset(stmt[stmt_sync]) ||
			sqlite3_step(stmt[stmt_count]) != SQLITE_ROW)
		{
			errmsg = sqlite3_errmsg(sqlite);
			return false;
		}

		count = 0;
		total = sqlite3_column_int(stmt[stmt_count], 0);
		sqlite3_reset(stmt[stmt_count]);

		int rc = sqlite3_step(stmt[stmt_sync]);

		metadb_handle_ptr handle;
		metadb_handle_list dead;
		file_info_impl info;

		string stamp1_tag(cfg_stamp1_tag), stamp1_format(cfg_stamp1_format),
			stamp2_tag(cfg_stamp2_tag), stamp2_format(cfg_stamp2_format);

		abort_callback_impl m_abort;
		static_api_ptr_t<metadb_io> p_imgr;

		while (s.process_pause() && rc == SQLITE_ROW)
		{
			const char * path = (const char *) sqlite3_column_text(stmt[stmt_sync], 0);
			s.set_item_path(path);
			p_metadb->handle_create(handle, make_playable_location(path, sqlite3_column_int(stmt[stmt_sync], 1)));
			if (input_entry::g_is_item_dead(handle->get_location(), m_abort) ||
				!p_library->is_item_in_library(handle)) dead.add_item(handle);
			else
			{
				large q[2] = {sqlite3_column_int64(stmt[stmt_sync], 2), sqlite3_column_int64(stmt[stmt_sync], 3)};
				handle->metadb_lock();
				if (handle->get_info(info))
				{
					info.info_set_int(field_counter, q[0]);
					info.info_set_int(field_timestamp, q[1]);
					if (length(stamp1_tag))
					{
						string val = format( q[1], stamp1_format );
						if (length(val))
							info.info_set(stamp1_tag,val);
					}
					if (length(stamp2_tag))
					{
						string val = format( q[1], stamp2_format );
						if (length(val))
							info.info_set(stamp2_tag,val);
					}
					p_imgr->update_info(handle, info, core_api::get_main_window(), true);
				}
				handle->metadb_unlock();
			}

			s.set_progress(++count, total);

			rc = sqlite3_step(stmt[stmt_sync]);
		}

		if (rc != SQLITE_DONE)
		{
			errmsg = sqlite3_errmsg(sqlite);
			return false;
		}

		if (dead.get_count())
		{
			s.set_title("Removing dead tracks...");
			s.set_progress(0);
			for (unsigned i = 0, j = dead.get_count(); s.process_pause() && (i < j);)
			{
				const playable_location & loc = dead.get_item(i)->get_location();
				s.set_item_path(loc.get_path());
				if (!remove(loc.get_path(), loc.get_subsong())) return false;
				s.set_progress(++i, j);
			}
		}

		return true;
	}
};

static state_mysql mysql;
static state_sqlite sqlite;

class cfg_int_db : public cfg_var
{
private:
	long val;
public:
	explicit inline cfg_int_db(const GUID & p_guid,long v) : cfg_var(p_guid)
	{
		val = byte_order::dword_native_to_le(v);
		set_raw_data(&val, sizeof(val));
	}
	inline long operator=(const cfg_int_db & v) {val=v;return val;}
	inline operator int() const {return val;}
	inline long operator=(int v) {val=v;return val;}

private:
	virtual bool get_raw_data(write_config_callback * out)
	{
		out->write_dword_le(val);
		return true;
	}

	virtual void set_raw_data(const void * data,int size)
	{
		if (size==sizeof(long))
		{
			val = byte_order::dword_le_to_native(*(t_uint32*)data);
			switch (val)
			{
			case 1:
				if (!sqlite.is_present())
				{
					if (mysql.is_present()) val = 2;
					else val = 0;
				}
				break;

			case 2:
				if (!mysql.is_present())
				{
					if (sqlite.is_present()) val = 1;
					else val = 0;
				}
				break;

			default:
				if (mysql.is_present()) val = 2;
				else if (sqlite.is_present()) val = 1;
				else val = 0;
				break;
			}
		}
	}
};

// {28E0B266-BA44-4bfe-BBB1-C79653142DD5}
static const GUID guid_cfg_which_db = 
{ 0x28e0b266, 0xba44, 0x4bfe, { 0xbb, 0xb1, 0xc7, 0x96, 0x53, 0x14, 0x2d, 0xd5 } };

static cfg_int_db cfg_which_db(guid_cfg_which_db, 0);

class my_startup
{
public:
	my_startup()
	{
		HMODULE h;

		h = uLoadLibrary("libmysql");
		if (h)
		{
			FreeLibrary(h);
			mysql.present = true;
		}

		h = uLoadLibrary("sqlite");
		if (h)
		{
			FARPROC p = GetProcAddress(h, "sqlite3_using_utf8api");
			FreeLibrary(h);
			if (p)
			{
				sqlite.present = true;
			}
		}
	}
};

static my_startup startup_info;

void sql_test(HWND wnd, bool create = false)
{
	switch (cfg_which_db)
	{
	case 1:
		if (!sqlite.init())
		{
			uMessageBox(wnd, sqlite.get_last_error(), "SQLite error", MB_ICONEXCLAMATION);
			return;
		}
		uMessageBox(wnd, "Opened successfully.", "SQLite", 0);
		break;

	case 2:
		bool rc;
		if (create) rc = mysql.create_table();
		else rc = mysql.init();
		if (!rc)
		{
			uMessageBox(wnd, mysql.get_last_error(), "MySQL error", MB_ICONEXCLAMATION);
			return;
		}
		if (create) uMessageBox(wnd, "Table created.", "MySQL", 0);
		else uMessageBox(wnd, "Connected successfully.", "MySQL", 0);
		break;

	default:
		uMessageBox(wnd, "No database libraries installed. Please install either\nlibmysql.dll or my version of sqlite.dll.", "Error", MB_ICONEXCLAMATION);
		break;
	}
}

static rwlock resync_lock;
static bool g_resync_running = false;

class resync_process : public threaded_process_callback
{
public:
	void run(threaded_process_status & p_status,abort_callback & p_abort)
	{
		{
			scopewrite lock(resync_lock);
			g_resync_running = true;
		}

		switch (cfg_which_db)
		{
		case 1:
			{
				state_sqlite * sqlite = new state_sqlite;
				if (!sqlite->resync(p_status))
				{
					uMessageBox(core_api::get_main_window(), sqlite->get_last_error(), "SQLite error", MB_ICONEXCLAMATION);
					delete sqlite;
					break;
				}
				delete sqlite;
				//uMessageBox(core_api::get_main_window(), "Resynchronization successful.", "SQLite", 0);
			}
			break;

		case 2:
			{
				state_mysql * mysql = new state_mysql;
				if (!mysql->resync(p_status))
				{
					uMessageBox(core_api::get_main_window(), mysql->get_last_error(), "MySQL error", MB_ICONEXCLAMATION);
					delete mysql;
					break;
				}
				delete mysql;
				//uMessageBox(core_api::get_main_window(), "Resynchronization successful.", "MySQL", 0);
			}
			break;

		default:
			uMessageBox(core_api::get_main_window(), "No database libraries installed. Please install either\nlibmysql.dll or my version of sqlite.dll.", "Error", MB_ICONEXCLAMATION);
			break;
		}

		{
			scopewrite lock(resync_lock);
			g_resync_running = false;
		}

		delete this;
	}
};

void sql_resync()
{
	{
		scoperead lock(resync_lock);
		if (g_resync_running)
		{
			uMessageBox(core_api::get_main_window(), "Resync already running.", "Error", MB_ICONEXCLAMATION);
			return;
		}
	}

	threaded_process_callback * p_callback = new resync_process;

	if (!threaded_process::g_run_modeless(*p_callback,
		threaded_process::flag_show_abort |
		threaded_process::flag_show_minimize |
		threaded_process::flag_show_progress |
		threaded_process::flag_show_item |
		threaded_process::flag_show_pause, core_api::get_main_window(), "Resync in progress..."))
	{
		delete p_callback;
		uMessageBox(core_api::get_main_window(), "Failed to start resync thread.", "Error", MB_ICONEXCLAMATION);
	}
}

class preferences_page_playcount : public preferences_page
{
	static void set_db(HWND w, int which)
	{
		BOOL show_mysql = (which == 2) ? TRUE : FALSE;
		BOOL show_all   = (which != 0) ? TRUE : FALSE;
		EnableWindow(GetDlgItem(w, IDC_DB_FRAME), show_mysql);
		EnableWindow(GetDlgItem(w, IDC_DB_HOST), show_mysql);
		EnableWindow(GetDlgItem(w, IDC_DB_USER), show_mysql);
		EnableWindow(GetDlgItem(w, IDC_DB_PASS), show_mysql);
		EnableWindow(GetDlgItem(w, IDC_DB_DB), show_mysql);
		EnableWindow(GetDlgItem(w, IDC_DB_TABLE), show_mysql);
		EnableWindow(GetDlgItem(w, IDC_DB_RESYNC), show_all);
		EnableWindow(GetDlgItem(w, IDC_DB_TEST), show_all);
		EnableWindow(GetDlgItem(w, IDC_DB_CREATE), show_mysql);

		cfg_which_db = which;
	}

	static BOOL CALLBACK DialogProc(HWND wnd,UINT msg,WPARAM wp,LPARAM lp)
	{
		HWND w;
		unsigned which;

		switch(msg)
		{
		case WM_INITDIALOG:
			uSetDlgItemText(wnd, IDC_DB_HOST, cfg_sql_host);
			uSetDlgItemText(wnd, IDC_DB_USER, cfg_sql_user);
			uSetDlgItemText(wnd, IDC_DB_PASS, cfg_sql_password);
			uSetDlgItemText(wnd, IDC_DB_DB, cfg_sql_db);
			uSetDlgItemText(wnd, IDC_DB_TABLE, cfg_sql_table);

			uSetDlgItemText(wnd,IDC_STAMP1_TAG,cfg_stamp1_tag);
			uSetDlgItemText(wnd,IDC_STAMP2_TAG,cfg_stamp2_tag);
			uSetDlgItemText(wnd,IDC_STAMP1_FORMAT,cfg_stamp1_format);
			uSetDlgItemText(wnd,IDC_STAMP2_FORMAT,cfg_stamp2_format);

			uSendDlgItemMessage(wnd,IDC_UPDATE_PERC,TBM_SETRANGE,0,MAKELONG(0,100));
			uSendDlgItemMessage(wnd,IDC_UPDATE_PERC,TBM_SETPOS,1,cfg_update_perc);
			uSetDlgItemText(wnd,IDC_PERC_STATUS,uStringPrintf("%u%%",(int)cfg_update_perc));

			which = 0;
			if (sqlite.is_present()) which |= 1;
			if (mysql.is_present()) which |= 2;

			if (!which)
			{
				ShowWindow(GetDlgItem(wnd, IDC_DB), SW_HIDE);
				uSetDlgItemText(wnd, IDC_DB_FRAME, "No database libraries installed.");
			}
			else if (which != 3)
			{
				ShowWindow(GetDlgItem(wnd, IDC_DB), SW_HIDE);
				uSetDlgItemText(wnd, IDC_DB_FRAME, (which == 1) ? "SQLite database" : "MySQL database");
			}
			else
			{
				w = GetDlgItem(wnd, IDC_DB);
				uSendMessageText(w, CB_ADDSTRING, 0, "SQLite");
				uSendMessageText(w, CB_ADDSTRING, 0, "MySQL");
				uSendMessage(w, CB_SETCURSEL, cfg_which_db - 1, 0);
			}

			set_db(wnd, cfg_which_db);

			return 1;
		case WM_COMMAND:
			switch(wp)
			{
			case (CBN_SELCHANGE << 16) | IDC_DB:
				set_db(wnd, uSendMessage((HWND)lp,CB_GETCURSEL,0,0) + 1);
				break;

			case IDC_MANUAL:
				// http://www.google.com/search?q=site%3Amsdn.microsoft.com+strftime&btnI
				uShellExecute(wnd, "open", "http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_crt_strftime.2c_.wcsftime.asp", NULL, NULL, SW_SHOWNORMAL);
				break;

			case IDC_DB_TEST:
				sql_test(wnd);
				break;
			case IDC_DB_CREATE:
				sql_test(wnd, true);
				break;

			case IDC_DB_RESYNC:
				sql_resync();
				break;

			case (EN_CHANGE<<16)|IDC_DB_HOST:
				cfg_sql_host = string_utf8_from_window((HWND)lp);
				break;
			case (EN_CHANGE<<16)|IDC_DB_USER:
				cfg_sql_user = string_utf8_from_window((HWND)lp);
				break;
			case (EN_CHANGE<<16)|IDC_DB_PASS:
				cfg_sql_password = string_utf8_from_window((HWND)lp);
				break;
			case (EN_CHANGE<<16)|IDC_DB_DB:
				cfg_sql_db = string_utf8_from_window((HWND)lp);
				break;
			case (EN_CHANGE<<16)|IDC_DB_TABLE:
				cfg_sql_table = string_utf8_from_window((HWND)lp);
				break;

			case (EN_CHANGE<<16)|IDC_STAMP1_TAG:
				cfg_stamp1_tag = string_utf8_from_window((HWND)lp);
				break;
			case (EN_CHANGE<<16)|IDC_STAMP2_TAG:
				cfg_stamp2_tag = string_utf8_from_window((HWND)lp);
				break;

			case (EN_CHANGE<<16)|IDC_STAMP1_FORMAT:
				cfg_stamp1_format = string_utf8_from_window((HWND)lp);
				break;
			case (EN_CHANGE<<16)|IDC_STAMP2_FORMAT:
				cfg_stamp2_format = string_utf8_from_window((HWND)lp);
				break;
			}
			break;

		case WM_HSCROLL:
			switch(uGetWindowLong((HWND)lp,GWL_ID))
			{
			case IDC_UPDATE_PERC:
				cfg_update_perc = uSendMessage((HWND)lp,TBM_GETPOS,0,0);
				uSetDlgItemText(wnd,IDC_PERC_STATUS,uStringPrintf("%u%%",(int)cfg_update_perc));
				break;
			}
			break;
		}
		return 0;
	}
public:
	HWND create(HWND parent)
	{
		return uCreateDialog(IDD_PLAYCOUNT_CONFIG,parent,DialogProc);
	}
	const char * get_name() {return "Play Count";}
	GUID get_parent_guid() {return guid_components;}

	GUID get_guid()
	{
		// {8DCAFC45-EBB3-439f-81EF-82FA9B34812E}
		static const GUID guid = 
		{ 0x8dcafc45, 0xebb3, 0x439f, { 0x81, 0xef, 0x82, 0xfa, 0x9b, 0x34, 0x81, 0x2e } };
		return guid;
	}

	bool reset_query() { return true; }
	virtual void reset()
	{
		cfg_update_perc = 50;

		cfg_stamp1_tag = "play_date";
		cfg_stamp2_tag = "play_time";
		cfg_stamp1_format = "%d%m%y";
		cfg_stamp2_format = "%H%M%S";

		cfg_sql_host = "localhost";
		cfg_sql_user = "foo";
		cfg_sql_password = "bar";
		cfg_sql_db = "foobar";
		cfg_sql_table = "playcount";

		cfg_last_played.clear();
		cfg_last_path = "";
		cfg_last_subsong = 0;

		cfg_which_db = 0;
	}
};

static preferences_page_factory_t<preferences_page_playcount> playconf;


class playcounter : public play_callback
{
private:
	metadb_handle_ptr _current;
	datetime _dt;
	bit_array_bittable _played;
	unsigned _length;

	void update_info(const metadb_handle_ptr & t)
	{
		if (t.is_empty() || !cfg_which_db)
			return;

		large * q;

		const playable_location & location = t->get_location();

		string path(location.get_path());
		int subsong = location.get_subsong();

		switch (cfg_which_db)
		{
		case 1:
			q = sqlite.query(path, subsong, _dt);
			if (!q)
			{
				console::warning(sqlite.get_last_error());
				return;
			}
			break;

		case 2:
			q = mysql.query(path, subsong, _dt);
			if (!q)
			{
				console::warning(mysql.get_last_error());
				return;
			}
			break;

		default:
			return;
		}

		string stamp1_tag(cfg_stamp1_tag), stamp1_format(cfg_stamp1_format),
			stamp2_tag(cfg_stamp2_tag), stamp2_format(cfg_stamp2_format);

		file_info_impl info;

		t->metadb_lock();

		if (t->get_info(info))
		{
			// update playcount
			info.info_set_int(field_counter, q[0]);
			info.info_set_int(field_timestamp, q[1]);

			// update timestamp tags
			if (length(stamp1_tag))
			{
				string val = format( q[1], stamp1_format );
				if (length(val))
					info.info_set(stamp1_tag,val);
			}

			if (length(stamp2_tag))
			{
				string val = format( q[1], stamp2_format );
				if (length(val))
					info.info_set(stamp2_tag,val);
			}

			if (io_result_failed(static_api_ptr_t<metadb_io>()->update_info(t, info, core_api::get_main_window(), true)))
				console::info("Error writing to DB.");
		}

		t->metadb_unlock();

		delete [] q;
	}

	bool has_played(unsigned played, unsigned len, unsigned perc )
	{
		return ((played*100)/len) >= perc;
	}

public:
	playcounter() : _played(0){}

	virtual unsigned get_callback_mask() 
	{return MASK_on_playback_new_track|MASK_on_playback_stop|MASK_on_playback_time;}

	virtual void on_playback_new_track(const metadb_handle_ptr & track)
	{
		if (!_current.is_empty())
		{
			unsigned secsPlayed =g_played.calc_count(true,0,g_length);
			if (has_played(secsPlayed,g_length,cfg_update_perc))
				update_info(_current);
			_current.release();
		}

		service_ptr_t<library_manager> p_library;
		library_manager::g_get(p_library);

		// store current track info
		int len = (int)(track->get_length()-(cfg_update_perc==100?1.0:0.0));
		if (len > 0 && p_library->is_item_in_library(track))
		{
			g_length = len;
			_current = track;
			cfg_last_path = _current->get_path();
			cfg_last_subsong = _current->get_subsong_index();
			_dt = now();
		}
		else
		{
			g_length = 0;
			cfg_last_path = "";
			cfg_last_subsong = 0;
			cfg_last_played.clear();
		}

		g_played.resize(0);
		if (g_length) g_played.resize(g_length);
	}

	virtual void on_playback_stop(play_control::stop_reason reason)
	{
		if (!_current.is_empty())
		{
			unsigned secsPlayed =g_played.calc_count(true,0,g_length);
			if (has_played(secsPlayed,g_length,cfg_update_perc))
				update_info(_current);
			_current.release();
		}
	}

	virtual void on_playback_time(const metadb_handle_ptr & track,double val)
	{
		if (!_current.is_empty())
		{
			if (cfg_last_played.get_count())
			{
				//console::info("handle last played");
				if (val==1.0)
				{
					//console::info("not a restart");
					cfg_last_played.clear();
				}
				else if (metadb::path_compare(cfg_last_path,_current->get_path())!=0 ||
					cfg_last_subsong != _current->get_subsong_index())
				{
					//console::info("not the same file");
					cfg_last_played.clear();  // should never happen?
				}
				else
				{
					//console::info("eval restart");
					cfg_last_played.get_table(g_played,g_length);
					cfg_last_played.clear();

					unsigned secsPlayed =g_played.calc_count(true,0,g_length);
					if (has_played(secsPlayed,g_length,cfg_update_perc))
					{
						//console::info("already updated");
						_current.release();
						return;
					}
					//console::info("retain info");
				}
			}

			g_played.set((int)val-1,true);

			unsigned secsPlayed = g_played.calc_count(true,0,g_length);
			if (has_played(secsPlayed,g_length,cfg_update_perc))
			{
				update_info(_current);
				_current.release();
			}
		}
	}

	virtual void on_playback_seek(double time){}
	virtual void on_playback_starting(){}
	virtual void on_playback_pause(int state){}
	virtual void on_playback_edited(const metadb_handle_ptr & track){}
	virtual void on_playback_dynamic_info(const file_info * info,bool b_track_change){}
	virtual void on_volume_change(int new_val){}
};

class TAG
{
	char * name, * value;

public:
	TAG()
	{
		name = NULL;
		value = NULL;
	}

	TAG(const char * _name, const char * _value)
	{
		name = new char[strlen(_name) + 1];
		strcpy(name, _name);
		value = new char[strlen(_value) + 1];
		strcpy(value, _value);
	}

	~TAG()
	{
		if (value) delete value;
		if (name) delete name;
	}

	inline const char * get_name() const
	{
		return name;
	}

	inline const char * get_value() const
	{
		return value;
	}
};

class MSGSTUFF
{
	char * path;
	int subsong;
	ptr_list_t<TAG> * tags;

public:
	MSGSTUFF()
	{
		path = NULL;
		tags = NULL;
	}

	MSGSTUFF(const char * _path, int _subsong, ptr_list_t<TAG> * _tags) : subsong(_subsong), tags(_tags)
	{
		path = new char[strlen(_path) + 1];
		strcpy(path, _path);
	}

	~MSGSTUFF()
	{
		if (tags)
		{
			tags->delete_all();
			delete tags;
		}

		if (path) delete path;
	}

	inline const char * get_path() const
	{
		return path;
	}
	
	inline int get_subsong() const
	{
		return subsong;
	}

	inline const ptr_list_t<TAG> * get_tags() const
	{
		return tags;
	}
};

class CMsgWnd
{
	critical_section sync;
	ptr_list_t<MSGSTUFF> msg;

public:

	CMsgWnd() : m_lpszClassName("B35E5EB8-0A18-476b-BC3F-60E7CECD8A5F")
	{
		m_bRegistered = FALSE;
		m_hWnd = NULL;
	}

	bool Initialize(HINSTANCE hInstance)
	{
		m_hInstance = hInstance;

		uWNDCLASS wcl;
		memset(&wcl, 0, sizeof(uWNDCLASS));
		wcl.hInstance = hInstance;
		wcl.lpfnWndProc = (WNDPROC)WndProc;
		wcl.lpszClassName = m_lpszClassName;
		if (!uRegisterClass(&wcl)) return false;

		m_bRegistered = TRUE;

		m_hWnd = uCreateWindowEx(0, m_lpszClassName, "uninteresting", 0, 0, 0, 0, 0, 0, 0, hInstance, this);

		return !!m_hWnd;
	}

	~CMsgWnd()
	{
		insync(sync);
		if (msg.get_count()) uSendMessage(m_hWnd, WM_UPDATE_INFO, 0, 0);
		if (IsWindow(m_hWnd)) DestroyWindow(m_hWnd);
		if (m_bRegistered)
			uUnregisterClass(m_lpszClassName, m_hInstance);
		msg.delete_all();
	}

	void Update(const char * path, int subsong, ptr_list_t<TAG> * tags)
	{
		insync(sync);
		msg.add_item(new MSGSTUFF(path, subsong, tags));
		if (IsWindow(m_hWnd)) uPostMessage(m_hWnd, WM_UPDATE_INFO, 0, 0);
	}

private:
	enum {
		WM_UPDATE_INFO = WM_USER
	};

	static LRESULT CALLBACK WndProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
	{
		static CMsgWnd *pThis = NULL;
		if(uMessage == WM_CREATE)
		{
			pThis = (CMsgWnd *)((CREATESTRUCT *)(lParam))->lpCreateParams;
		}

		return pThis->WindowProc(hWnd, uMessage, wParam, lParam);
	}

	LRESULT CALLBACK WindowProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
	{
		if (uMessage == WM_UPDATE_INFO)
		{
			insync(sync);
			unsigned i, count = msg.get_count();
			for (i = 0; i < count; i++)
			{
				MSGSTUFF * m = msg[i];
				playable_location_i loc(m->get_path(), m->get_subsong());
				service_ptr_t<metadb> p_metadb;
				metadb::g_get(p_metadb);
				metadb_handle_ptr handle;
				p_metadb->handle_create(handle, loc);

				file_info_impl info;

				static_api_ptr_t<metadb_io> p_mdbio;
				
				p_mdbio->load_info(handle, metadb_io::load_info_default, core_api::get_main_window(), true);

				const ptr_list_t<TAG> * tags = m->get_tags();

				unsigned n, tcount = tags->get_count();

				for (n = 0; n < tcount; n++)
				{
					TAG * tag = (*tags)[n];
					info.info_set(tag->get_name(), tag->get_value());
				}

				p_mdbio->update_info(handle, info, core_api::get_main_window(), true);
			}
			msg.delete_all();
		}

		return uDefWindowProc(hWnd, uMessage, wParam, lParam);
	}

	HINSTANCE	m_hInstance;
	HWND		m_hWnd;
	const char *m_lpszClassName;
	BOOL		m_bRegistered;
};

CMsgWnd * g_msgwnd = NULL;

class playcount_initquit : public initquit
{
	virtual void on_init()
	{
		g_msgwnd = new CMsgWnd;
		if (!g_msgwnd->Initialize(core_api::get_my_instance()))
		{
			delete g_msgwnd;
			g_msgwnd = NULL;
		}
	}
	virtual void on_quit()
	{
		if (g_msgwnd)
		{
			delete g_msgwnd;
			g_msgwnd = NULL;
		}
		cfg_last_played.set_table(g_played,g_length);
	}
};

class playdb : public file_operation_callback
{
/*	virtual void on_info_reloaded(const metadb_handle_ptr & handle)
	{
		if (g_msgwnd && cfg_which_db)
		{
			const playable_location & loc = handle->get_location();

			string path(loc.get_path());
			int subsong = loc.get_subsong_index();

			large * q;

			switch (cfg_which_db)
			{
			case 1:
				q = sqlite.query(path, subsong);
				if (!q)
				{
					console::warning(sqlite.get_last_error());
					return;
				}
				break;

			case 2:
				q = mysql.query(path, subsong);
				if (!q)
				{
					console::warning(mysql.get_last_error());
					return;
				}
				break;
			}

			if (q[0])
			{
				string stamp1_tag(cfg_stamp1_tag), stamp1_format(cfg_stamp1_format),
					stamp2_tag(cfg_stamp2_tag), stamp2_format(cfg_stamp2_format);
				char temp[32];
				ptr_list_t<TAG> * tags = new ptr_list_t<TAG>;
				tags->add_item(new TAG(field_counter, _i64toa(q[0], temp, 10)));
				tags->add_item(new TAG(field_timestamp, _i64toa(q[1], temp, 10)));
				if (length(stamp1_tag))
				{
					string val = format( q[1], stamp1_format );
					if (length(val))
						tags->add_item(new TAG(stamp1_tag, val));
				}
				if (length(stamp2_tag))
				{
					string val = format( q[1], stamp2_format );
					if (length(val))
						tags->add_item(new TAG(stamp2_tag, val));
				}

				g_msgwnd->Update(path, subsong, tags);
			}

			delete [] q;
		}
	}

	virtual void on_file_removed_user(const metadb_handle_ptr & handle)
	{
		on_file_removed(handle);
	}*/

	virtual void on_file_deleted(const metadb_handle_ptr & handle)
	{
		if (!cfg_which_db) return;

		const playable_location & loc = handle->get_location();

		string path(loc.get_path());
		int subsong = loc.get_subsong_index();

		switch (cfg_which_db)
		{
		case 1:
			if (!sqlite.remove(path, subsong))
			{
				console::warning(sqlite.get_last_error());
			}
			break;

		case 2:
			if (!mysql.remove(path, subsong))
			{
				console::warning(mysql.get_last_error());
			}
			break;
		}
	}

	virtual void on_file_moved(const metadb_handle_ptr & src, const metadb_handle_ptr & dst)
	{
		if (!cfg_which_db) return;

		const playable_location & old_loc = src->get_location();
		const playable_location & new_loc = dst->get_location();

		string
			old_path(old_loc.get_path()),
			new_path(new_loc.get_path());
		int
			old_subsong = old_loc.get_subsong_index(),
			new_subsong = new_loc.get_subsong_index();

		if (old_path != new_path || old_subsong != new_subsong)
		{
			switch (cfg_which_db)
			{
			case 1:
				if (!sqlite.moved(old_path, old_subsong, new_path, new_subsong))
				{
					console::warning(sqlite.get_last_error());
				}
				break;

			case 2:
				if (!mysql.moved(old_path, old_subsong, new_path, new_subsong))
				{
					console::warning(mysql.get_last_error());
				}
				break;
			}
		}
	}
};

static play_callback_factory<playcounter> g_play_callback_playcounter_factory;
static initquit_factory<playcount_initquit> g_initquit_playcount_factory;
static service_factory_single_t<file_operation_callback,playdb> g_metadb_callback_playcount_factory;

DECLARE_COMPONENT_VERSION("Play Count",MY_VERSION,"Keeps track play count and last played date");
